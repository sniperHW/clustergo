package ss

import (
	"github.com/golang/protobuf/proto"
	"github.com/sniperHW/sanguo/cluster/addr"
	"github.com/sniperHW/sanguo/cluster/rpcerr"
	"github.com/sniperHW/sanguo/codec/pb"
	"github.com/sniperHW/sanguo/pkg/buffer"
	"github.com/sniperHW/sanguo/pkg/rpc"
	_ "github.com/sniperHW/sanguo/protocol/ss"
)

const (
	sizeLen      = 4
	sizeFlag     = 1
	sizeTo       = 4
	sizeFrom     = 4
	sizeCmd      = 2
	sizeRPCSeqNo = 8
	headerSize   = sizeLen + sizeFlag + sizeTo + sizeFrom + sizeCmd + sizeRPCSeqNo
)

const (
	RELAY        = 0x4  //跨集群透传消息
	MESSAGE      = 0x8  //普通消息
	RPCREQ       = 0x10 //RPC请求
	RPCRESP      = 0x18 //RPC响应
	RPCERR       = 0x20 //PRC响应错误信息
	COMPRESS     = 0x80
	RPC_NEEDRESP = 0x1
	MESSAGE_TYPE = 0x38
)

func setCompressFlag(flag *byte) {
	*flag |= COMPRESS
}

func getCompresFlag(flag byte) bool {
	return (flag & COMPRESS) != 0
}

func setMsgType(flag *byte, tt byte) {
	if tt == MESSAGE || tt == RPCREQ || tt == RPCRESP || tt == RPCERR {
		*flag |= tt
	}
}

func getMsgType(flag byte) byte {
	return flag & MESSAGE_TYPE
}

func setRelay(flag *byte) {
	*flag |= RELAY
}

func isRelay(flag byte) bool {
	return (flag & RELAY) != 0
}

func setNeedRPCResp(flag *byte) {
	*flag |= RPC_NEEDRESP
}

func getNeedRPCResp(flag byte) bool {
	return (flag & RPC_NEEDRESP) != 0
}

type Encoder struct {
	ns_msg  string
	ns_req  string
	ns_resp string
}

func NewEncoder(ns_msg, ns_req, ns_resp string) *Encoder {
	return &Encoder{ns_msg: ns_msg, ns_req: ns_req, ns_resp: ns_resp}
}

func (this *Encoder) encode(b []byte, o interface{}, relayInfo []addr.LogicAddr) []byte {
	var pbbytes []byte
	var cmd uint32
	var err error
	var payloadLen int
	var totalLen int
	flag := byte(0)

	if nil != relayInfo {
		payloadLen = 8
		setRelay(&flag)
	}

	switch o.(type) {
	case proto.Message:

		if pbbytes, cmd, err = pb.Marshal(this.ns_msg, o); err != nil {
			//log
			return b
		}

		payloadLen += (sizeFlag + sizeCmd + len(pbbytes))

		totalLen = (sizeLen + payloadLen)
		if totalLen > maxPacketSize {
			//log
			return b
			//return fmt.Errorf("packet too large totalLen:%d", totalLen)
		}

		//写payload大小
		b = buffer.AppendInt(b, payloadLen)

		//设置普通消息标记
		setMsgType(&flag, MESSAGE)
		//写flag
		b = buffer.AppendByte(b, flag)

		if isRelay(flag) {
			b = buffer.AppendUint32(b, uint32(relayInfo[0]))
			b = buffer.AppendUint32(b, uint32(relayInfo[1]))
		}

		//写cmd
		b = buffer.AppendUint16(b, uint16(cmd))
		//写数据
		return buffer.AppendBytes(b, pbbytes)

	case *rpc.RPCRequest:

		request := o.(*rpc.RPCRequest)

		if pbbytes, cmd, err = pb.Marshal(this.ns_req, request.Arg); err != nil {
			//log
			return b
		}

		payloadLen += (len(pbbytes) + sizeFlag + sizeCmd + sizeRPCSeqNo)

		//写payload大小
		b = buffer.AppendInt(b, payloadLen)

		//设置RPC请求标记
		setMsgType(&flag, RPCREQ)

		//如果需要返回设置返回需要返回标记
		if request.NeedResp {
			setNeedRPCResp(&flag)
		}
		//写flag
		b = buffer.AppendByte(b, flag)

		if isRelay(flag) {
			b = buffer.AppendUint32(b, uint32(relayInfo[0]))
			b = buffer.AppendUint32(b, uint32(relayInfo[1]))
		}

		//写cmd
		b = buffer.AppendUint16(b, uint16(cmd))
		//写RPC序列号
		b = buffer.AppendUint64(b, uint64(request.Seq))
		//写数据
		return buffer.AppendBytes(b, pbbytes)
	case *rpc.RPCResponse:

		response := o.(*rpc.RPCResponse)

		if response.Err == nil {
			if pbbytes, cmd, err = pb.Marshal(this.ns_resp, response.Ret); err != nil {
				//log
				return b
			}

			payloadLen += (len(pbbytes) + sizeFlag + sizeCmd + sizeRPCSeqNo)

			//写payload大小
			b = buffer.AppendInt(b, payloadLen)

			//设置RPC响应标记
			setMsgType(&flag, RPCRESP)
			//写flag
			b = buffer.AppendByte(b, flag)

			if isRelay(flag) {
				b = buffer.AppendUint32(b, uint32(relayInfo[0]))
				b = buffer.AppendUint32(b, uint32(relayInfo[1]))
			}

			//写cmd
			b = buffer.AppendUint16(b, uint16(cmd))
			//写RPC序列号
			b = buffer.AppendUint64(b, response.Seq)

			//写数据
			return buffer.AppendBytes(b, pbbytes)
		} else {

			errStr := rpcerr.GetShortStrByError(response.Err)

			payloadLen += (len(errStr) + sizeFlag + sizeCmd + sizeRPCSeqNo)

			//写payload大小
			b = buffer.AppendInt(b, payloadLen)

			//设置RPC响应标记
			setMsgType(&flag, RPCERR)
			//写flag
			b = buffer.AppendByte(b, flag)

			if isRelay(flag) {
				b = buffer.AppendUint32(b, uint32(relayInfo[0]))
				b = buffer.AppendUint32(b, uint32(relayInfo[1]))
			}

			//写cmd
			b = buffer.AppendUint16(b, uint16(cmd))
			//写RPC序列号
			b = buffer.AppendUint64(b, response.Seq)
			//写数据
			return buffer.AppendString(b, errStr)
		}
	default:
		panic("error")
		return b
	}
}

func (this *Encoder) enCodeRPCRelayError(b []byte, msg *RPCRelayErrorMessage) []byte {

	var payloadLen int

	flag := byte(0)

	setRelay(&flag)

	errMsg := rpcerr.GetShortStrByError(msg.Err)

	payloadLen += (len(errMsg) + sizeFlag + sizeCmd + sizeRPCSeqNo + 8)

	//写payload大小
	b = buffer.AppendInt(b, payloadLen)

	//设置RPC响应标记
	setMsgType(&flag, RPCERR)
	//写flag
	b = buffer.AppendByte(b, flag)

	b = buffer.AppendUint32(b, uint32(msg.To))
	b = buffer.AppendUint32(b, uint32(msg.From))

	//写cmd
	b = buffer.AppendUint16(b, uint16(0))
	//写RPC序列号
	b = buffer.AppendUint64(b, msg.Seqno)
	//写数据
	return buffer.AppendString(b, errMsg)
}

func (this *Encoder) Pack(b []byte, o interface{}) []byte {
	switch o.(type) {
	case *Message:
		return this.encode(b, o.(*Message).GetData(), o.(*Message).relayInfo)
	case proto.Message, *rpc.RPCRequest, *rpc.RPCResponse:
		return this.encode(b, o, nil)
	case *RelayMessage:
		return buffer.AppendBytes(b, o.(*RelayMessage).data)
	case *RPCRelayErrorMessage:
		return this.enCodeRPCRelayError(b, o.(*RPCRelayErrorMessage))
	default:
		return b
	}
}
